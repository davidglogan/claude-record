#!/bin/bash

# Claude Recording Wrapper Script
# Automatically records all Claude Code conversations with metadata and management features
#
# Author: Generated by Claude Code
# Version: 1.0
# 
# This script wraps the claude command to automatically record all interactions
# with timestamps, session metadata, and automatic log management.

set -euo pipefail

# Script configuration
SCRIPT_NAME="claude-record"
SCRIPT_VERSION="1.0"
DEFAULT_LOG_DIR="$HOME/Documents/claude"
DEFAULT_MAX_SIZE="100M"
DEFAULT_MAX_SESSIONS=50
CLAUDE_CMD="claude"

# Color codes for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

# Global variables
LOG_DIR="$DEFAULT_LOG_DIR"
CUSTOM_FILENAME=""
MAX_SIZE="$DEFAULT_MAX_SIZE"
MAX_SESSIONS="$DEFAULT_MAX_SESSIONS"
VERBOSE=false
DRY_RUN=false
CLEANUP_ONLY=false
LIST_SESSIONS=false
SEARCH_TERM=""
AUTO_CLEANUP=true

# Utility functions
log_info() {
    echo -e "${CYAN}[INFO]${NC} $1" >&2
}

log_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1" >&2
}

log_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1" >&2
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1" >&2
}

verbose_log() {
    if [[ "$VERBOSE" == "true" ]]; then
        echo -e "${PURPLE}[VERBOSE]${NC} $1" >&2
    fi
}

# Convert human readable sizes to bytes
size_to_bytes() {
    local size="$1"
    local num="${size%[KMGT]*}"
    local unit="${size#$num}"
    
    case "${unit^^}" in
        K|KB) echo $((num * 1024)) ;;
        M|MB) echo $((num * 1024 * 1024)) ;;
        G|GB) echo $((num * 1024 * 1024 * 1024)) ;;
        T|TB) echo $((num * 1024 * 1024 * 1024 * 1024)) ;;
        *) echo "$num" ;;
    esac
}

# Format bytes to human readable
bytes_to_size() {
    local bytes="$1"
    if (( bytes > 1073741824 )); then
        printf "%.1fG" $((bytes / 1073741824))
    elif (( bytes > 1048576 )); then
        printf "%.1fM" $((bytes / 1048576))
    elif (( bytes > 1024 )); then
        printf "%.1fK" $((bytes / 1024))
    else
        printf "%dB" "$bytes"
    fi
}

# Display help
show_help() {
    cat << EOF
$SCRIPT_NAME v$SCRIPT_VERSION - Claude Code Session Recording Wrapper

USAGE:
    $SCRIPT_NAME [OPTIONS] [CLAUDE_ARGS...]

DESCRIPTION:
    Automatically records Claude Code conversations with timestamps, metadata,
    and intelligent log management. All Claude arguments are passed through.

OPTIONS:
    -h, --help              Show this help message
    -d, --directory DIR     Recording directory (default: $DEFAULT_LOG_DIR)
    -f, --filename NAME     Custom filename prefix (default: claude_conversation)
    -s, --max-size SIZE     Maximum log file size before rotation (default: $DEFAULT_MAX_SIZE)
    -m, --max-sessions NUM  Maximum number of session files to keep (default: $DEFAULT_MAX_SESSIONS)
    -v, --verbose           Enable verbose output
    --dry-run              Show what would be done without executing
    --cleanup              Clean up old sessions and exit
    --list                 List all recorded sessions and exit
    --search TERM          Search through recorded sessions for TERM
    --no-auto-cleanup      Disable automatic cleanup of old sessions
    --version              Show version information

SIZE FORMAT:
    Sizes can be specified with suffixes: K/KB, M/MB, G/GB, T/TB
    Examples: 50M, 1G, 512K, 2048

EXAMPLES:
    # Basic usage - record a Claude session
    $SCRIPT_NAME

    # Custom directory and filename
    $SCRIPT_NAME -d ~/my-claude-logs -f my_session

    # Limit file size and keep more sessions
    $SCRIPT_NAME -s 50MB -m 100

    # Pass arguments to Claude
    $SCRIPT_NAME --model claude-3-sonnet

    # List all recorded sessions
    $SCRIPT_NAME --list

    # Search for specific content in sessions
    $SCRIPT_NAME --search "performance test"

    # Clean up old sessions
    $SCRIPT_NAME --cleanup

FILES:
    Session files are saved as:
    \$LOG_DIR/claude_conversation.YYYYMMDD-HHMMSS.log

    Metadata files are saved as:
    \$LOG_DIR/claude_conversation.YYYYMMDD-HHMMSS.meta

FEATURES:
    • Automatic timestamping and session metadata
    • File size monitoring with automatic rotation
    • Intelligent cleanup of old sessions
    • Search functionality across all sessions
    • Session listing with metadata
    • Progress indicators for long sessions
    • Error handling and recovery
    • Support for all Claude Code arguments

ENVIRONMENT VARIABLES:
    CLAUDE_RECORD_DIR       Default recording directory
    CLAUDE_RECORD_MAX_SIZE  Default maximum file size
    CLAUDE_CMD              Claude command to execute (default: claude)

EOF
}

# Create log directory
setup_log_directory() {
    if [[ ! -d "$LOG_DIR" ]]; then
        verbose_log "Creating log directory: $LOG_DIR"
        if [[ "$DRY_RUN" == "false" ]]; then
            mkdir -p "$LOG_DIR" || {
                log_error "Failed to create log directory: $LOG_DIR"
                exit 1
            }
        fi
        log_success "Created log directory: $LOG_DIR"
    fi
    
    # Ensure we can write to the directory
    if [[ "$DRY_RUN" == "false" ]] && [[ ! -w "$LOG_DIR" ]]; then
        log_error "Cannot write to log directory: $LOG_DIR"
        exit 1
    fi
}

# Generate session filename
generate_filename() {
    local timestamp=$(date +%Y%m%d-%H%M%S)
    local prefix="${CUSTOM_FILENAME:-claude_conversation}"
    echo "${LOG_DIR}/${prefix}.${timestamp}.log"
}

# Generate metadata filename
generate_metadata_filename() {
    local log_file="$1"
    echo "${log_file%.log}.meta"
}

# Create session metadata
create_metadata() {
    local log_file="$1"
    local meta_file="$(generate_metadata_filename "$log_file")"
    local start_time="$2"
    
    verbose_log "Creating metadata file: $meta_file"
    
    if [[ "$DRY_RUN" == "false" ]]; then
        cat > "$meta_file" << EOF
# Claude Session Metadata
session_start="$start_time"
session_file="$(basename "$log_file")"
session_directory="$LOG_DIR"
claude_args="$*"
max_size="$MAX_SIZE"
hostname="$(hostname)"
user="$(whoami)"
pwd="$(pwd)"
script_version="$SCRIPT_VERSION"
EOF
    fi
}

# Update metadata on session end
update_metadata() {
    local log_file="$1"
    local meta_file="$(generate_metadata_filename "$log_file")"
    local end_time="$2"
    local file_size="$3"
    
    if [[ "$DRY_RUN" == "false" ]] && [[ -f "$meta_file" ]]; then
        {
            echo "session_end=\"$end_time\""
            echo "final_size=\"$file_size\""
            echo "duration_seconds=\"$(( $(date -d "$end_time" +%s) - $(date -d "$(grep session_start "$meta_file" | cut -d'"' -f2)" +%s) ))\""
        } >> "$meta_file"
    fi
}

# Check if file exceeds size limit
check_file_size() {
    local file="$1"
    local max_bytes=$(size_to_bytes "$MAX_SIZE")
    
    if [[ -f "$file" ]]; then
        local current_size=$(stat -f%z "$file" 2>/dev/null || stat -c%s "$file" 2>/dev/null || echo 0)
        if (( current_size > max_bytes )); then
            return 0  # File is too large
        fi
    fi
    return 1  # File is within limits
}

# Rotate log file if needed
rotate_log_if_needed() {
    local log_file="$1"
    
    if check_file_size "$log_file"; then
        local rotated_file="${log_file%.log}.$(date +%H%M%S).log"
        verbose_log "Rotating log file: $log_file -> $(basename "$rotated_file")"
        
        if [[ "$DRY_RUN" == "false" ]]; then
            mv "$log_file" "$rotated_file"
            # Update metadata for rotated file
            local meta_file="$(generate_metadata_filename "$log_file")"
            local rotated_meta="${rotated_file%.log}.meta"
            if [[ -f "$meta_file" ]]; then
                mv "$meta_file" "$rotated_meta"
                echo "rotated_at=\"$(date -Iseconds)\"" >> "$rotated_meta"
            fi
        fi
        
        log_info "Log file rotated due to size limit ($(bytes_to_size $(size_to_bytes "$MAX_SIZE")))"
        return 0  # File was rotated
    fi
    return 1  # No rotation needed
}

# Filter out repetitive Claude UI sequences
filter_claude_ui_sequences() {
    local input_file="$1"
    local output_file="$2"
    
    if [[ ! -f "$input_file" ]]; then
        log_error "Input file not found: $input_file"
        return 1
    fi
    
    verbose_log "Filtering Claude UI sequences to reduce log size"
    
    # Use sed and grep to filter out repetitive patterns
    # Remove ANSI escape sequences, repetitive cursor movements, and cooking animations
    sed -E '
        # Remove ANSI color codes and cursor control sequences
        s/\x1b\[[0-9;]*[mGKH]//g
        s/\x1b\[[0-9]*[ABCD]//g
        s/\x1b\[2K//g
        s/\x1b\[\?[0-9]+[hl]//g
        # Remove repetitive cursor positioning
        s/\x1b\[[0-9]+;[0-9]+H//g
        # Remove form feed and other control chars except newlines
        s/[\x0C\x0E\x0F]//g
    ' "$input_file" | \
    # Filter out lines that are mostly repetitive UI elements
    grep -v -E '(╭─+╮|│.*│|╰─+╯)$' | \
    # Remove excessive blank lines (keep max 2 consecutive)
    awk '
        /^[[:space:]]*$/ { 
            blank++; 
            if (blank <= 2) print; 
            next 
        } 
        { blank=0; print }
    ' > "$output_file"
    
    local original_size=$(stat -c%s "$input_file" 2>/dev/null || echo 0)
    local filtered_size=$(stat -c%s "$output_file" 2>/dev/null || echo 0)
    local reduction=$((original_size - filtered_size))
    
    verbose_log "Log size reduced by $(bytes_to_size $reduction) ($(printf "%.1f" $(echo "scale=1; $reduction * 100 / $original_size" | bc 2>/dev/null || echo "0"))%)"
}

# Clean up old sessions
cleanup_old_sessions() {
    verbose_log "Cleaning up old sessions (keeping $MAX_SESSIONS most recent)"
    
    local session_files=()
    while IFS=  read -r -d $'\0' file; do
        session_files+=("$file")
    done < <(find "$LOG_DIR" -name "*.log" -print0 2>/dev/null | sort -z)
    
    local total_files=${#session_files[@]}
    verbose_log "Found $total_files session files"
    
    if (( total_files > MAX_SESSIONS )); then
        local files_to_remove=$((total_files - MAX_SESSIONS))
        log_info "Removing $files_to_remove old session files"
        
        for (( i=0; i<files_to_remove; i++ )); do
            local file="${session_files[i]}"
            local meta_file="$(generate_metadata_filename "$file")"
            
            verbose_log "Removing: $(basename "$file")"
            if [[ "$DRY_RUN" == "false" ]]; then
                rm -f "$file" "$meta_file"
            fi
        done
        
        log_success "Cleaned up $files_to_remove old session files"
    else
        verbose_log "No cleanup needed (have $total_files, limit $MAX_SESSIONS)"
    fi
}

# List all sessions
list_sessions() {
    log_info "Recorded Claude Sessions in $LOG_DIR:"
    echo
    
    local sessions=()
    while IFS=  read -r -d $'\0' file; do
        sessions+=("$file")
    done < <(find "$LOG_DIR" -name "*.log" -print0 2>/dev/null | sort -z -r)
    
    if [[ ${#sessions[@]} -eq 0 ]]; then
        echo "No recorded sessions found."
        return
    fi
    
    printf "%-20s %-12s %-8s %-20s %s\n" "SESSION" "DATE" "SIZE" "DURATION" "ARGS"
    printf "%-20s %-12s %-8s %-20s %s\n" "-------" "----" "----" "--------" "----"
    
    for session in "${sessions[@]}"; do
        local basename_session=$(basename "$session")
        local meta_file="$(generate_metadata_filename "$session")"
        local size="N/A"
        local date="N/A"
        local duration="N/A"
        local args="N/A"
        
        # Get file size
        if [[ -f "$session" ]]; then
            local bytes=$(stat -f%z "$session" 2>/dev/null || stat -c%s "$session" 2>/dev/null || echo 0)
            size=$(bytes_to_size "$bytes")
        fi
        
        # Get metadata if available
        if [[ -f "$meta_file" ]]; then
            date=$(grep "session_start=" "$meta_file" 2>/dev/null | cut -d'"' -f2 | cut -d'T' -f1 || echo "N/A")
            local duration_sec=$(grep "duration_seconds=" "$meta_file" 2>/dev/null | cut -d'"' -f2 || echo "")
            if [[ -n "$duration_sec" ]]; then
                if (( duration_sec >= 3600 )); then
                    duration=$(printf "%dh%dm" $((duration_sec/3600)) $(((duration_sec%3600)/60)))
                elif (( duration_sec >= 60 )); then
                    duration=$(printf "%dm%ds" $((duration_sec/60)) $((duration_sec%60)))
                else
                    duration="${duration_sec}s"
                fi
            fi
            args=$(grep "claude_args=" "$meta_file" 2>/dev/null | cut -d'"' -f2 | head -c 30 || echo "")
            [[ ${#args} -eq 30 ]] && args="${args}..."
        fi
        
        printf "%-20s %-12s %-8s %-20s %s\n" "${basename_session:0:18}" "$date" "$size" "$duration" "$args"
    done
    
    echo
    log_info "Total sessions: ${#sessions[@]}"
}

# Search through sessions
search_sessions() {
    local search_term="$1"
    log_info "Searching for '$search_term' in recorded sessions..."
    echo
    
    local found_count=0
    local session_count=0
    
    while IFS= read -r -d $'\0' session; do
        ((session_count++))
        local basename_session=$(basename "$session")
        
        # Search in the session file
        if grep -l -i "$search_term" "$session" >/dev/null 2>&1; then
            ((found_count++))
            echo -e "${GREEN}=== $basename_session ===${NC}"
            
            # Show matching lines with context
            grep -i -n -C 2 --color=always "$search_term" "$session" | head -20
            echo
        fi
    done < <(find "$LOG_DIR" -name "*.log" -print0 2>/dev/null)
    
    if [[ $found_count -eq 0 ]]; then
        log_warning "No sessions found containing '$search_term'"
    else
        log_success "Found '$search_term' in $found_count out of $session_count sessions"
    fi
}

# Check if Claude command exists
check_claude_command() {
    if ! command -v "$CLAUDE_CMD" &> /dev/null; then
        log_error "Claude command '$CLAUDE_CMD' not found in PATH"
        log_error "Please install Claude Code or set CLAUDE_CMD environment variable"
        exit 1
    fi
}

# Parse command line arguments
parse_args() {
    while [[ $# -gt 0 ]]; do
        case $1 in
            -h|--help)
                show_help
                exit 0
                ;;
            -d|--directory)
                LOG_DIR="$2"
                shift 2
                ;;
            -f|--filename)
                CUSTOM_FILENAME="$2"
                shift 2
                ;;
            -s|--max-size)
                MAX_SIZE="$2"
                shift 2
                ;;
            -m|--max-sessions)
                MAX_SESSIONS="$2"
                shift 2
                ;;
            -v|--verbose)
                VERBOSE=true
                shift
                ;;
            --dry-run)
                DRY_RUN=true
                shift
                ;;
            --cleanup)
                CLEANUP_ONLY=true
                shift
                ;;
            --list)
                LIST_SESSIONS=true
                shift
                ;;
            --search)
                SEARCH_TERM="$2"
                shift 2
                ;;
            --no-auto-cleanup)
                AUTO_CLEANUP=false
                shift
                ;;
            --version)
                echo "$SCRIPT_NAME version $SCRIPT_VERSION"
                exit 0
                ;;
            --)
                shift
                break
                ;;
            -*)
                log_error "Unknown option: $1"
                echo "Use --help for usage information"
                exit 1
                ;;
            *)
                break
                ;;
        esac
    done
    
    # Remaining arguments are passed to Claude
    CLAUDE_ARGS=("$@")
}

# Validate arguments
validate_args() {
    # Validate max size format
    if ! [[ "$MAX_SIZE" =~ ^[0-9]+[KMGT]?B?$ ]]; then
        log_error "Invalid size format: $MAX_SIZE"
        log_error "Use formats like: 50M, 1G, 512K, 2048"
        exit 1
    fi
    
    # Validate max sessions is a number
    if ! [[ "$MAX_SESSIONS" =~ ^[0-9]+$ ]]; then
        log_error "Invalid max sessions: $MAX_SESSIONS (must be a number)"
        exit 1
    fi
    
    # Expand LOG_DIR
    LOG_DIR="${LOG_DIR/#\~/$HOME}"
    
    # Override with environment variables if set
    [[ -n "${CLAUDE_RECORD_DIR:-}" ]] && LOG_DIR="$CLAUDE_RECORD_DIR"
    [[ -n "${CLAUDE_RECORD_MAX_SIZE:-}" ]] && MAX_SIZE="$CLAUDE_RECORD_MAX_SIZE"
    [[ -n "${CLAUDE_CMD:-}" ]] && CLAUDE_CMD="$CLAUDE_CMD"
}

# Main execution
main() {
    # Parse and validate arguments
    parse_args "$@"
    validate_args
    
    # Handle special modes
    if [[ "$LIST_SESSIONS" == "true" ]]; then
        setup_log_directory
        list_sessions
        exit 0
    fi
    
    if [[ -n "$SEARCH_TERM" ]]; then
        setup_log_directory
        search_sessions "$SEARCH_TERM"
        exit 0
    fi
    
    if [[ "$CLEANUP_ONLY" == "true" ]]; then
        setup_log_directory
        cleanup_old_sessions
        exit 0
    fi
    
    # Check for Claude command
    check_claude_command
    
    # Setup environment
    setup_log_directory
    
    # Auto-cleanup if enabled
    if [[ "$AUTO_CLEANUP" == "true" ]]; then
        cleanup_old_sessions
    fi
    
    # Generate log file
    local log_file
    log_file=$(generate_filename)
    local start_time=$(date -Iseconds)
    
    verbose_log "Session will be recorded to: $(basename "$log_file")"
    verbose_log "Maximum file size: $MAX_SIZE"
    verbose_log "Claude command: $CLAUDE_CMD ${CLAUDE_ARGS[*]:-}"
    
    if [[ "$DRY_RUN" == "true" ]]; then
        log_info "DRY RUN - Would execute: $CLAUDE_CMD ${CLAUDE_ARGS[*]:-}"
        log_info "Would record to: $log_file"
        exit 0
    fi
    
    # Create metadata
    create_metadata "$log_file" "$start_time" "${CLAUDE_ARGS[@]:-}"
    
    log_info "Starting Claude session recording..."
    log_info "Session file: $(basename "$log_file")"
    log_info "Press Ctrl+C to end session"
    echo
    
    # Start recording session
    local exit_code=0
    
    # Create header for log file
    {
        echo "=== Claude Session Started at $start_time ==="
        echo "Command: $CLAUDE_CMD ${CLAUDE_ARGS[*]:-}"
        echo "Directory: $(pwd)"
        echo "User: $(whoami)@$(hostname)"
        echo "=== Session Log ==="
        echo
    } > "$log_file"
    
    # Use script -B to record both input and output, then filter
    local raw_log_file="${log_file}.raw"
    
    # Force interactive mode if no arguments provided
    if [[ ${#CLAUDE_ARGS[@]:-0} -eq 0 ]]; then
        # No arguments - force interactive mode by not passing --print
        script -B "$raw_log_file" -a -c "$CLAUDE_CMD" || exit_code=$?
    else
        # Arguments provided - pass them through
        script -B "$raw_log_file" -a -c "$CLAUDE_CMD ${CLAUDE_ARGS[*]}" || exit_code=$?
    fi
    
    # Filter out repetitive Claude UI sequences to reduce log size
    verbose_log "Filtering repetitive UI sequences from log..."
    filter_claude_ui_sequences "$raw_log_file" "$log_file"
    
    # Remove raw log file
    rm -f "$raw_log_file"
    
    # Add footer to log file
    {
        echo
        echo "=== Session Ended at $(date -Iseconds) ==="
    } >> "$log_file"
    
    # Update metadata
    local end_time=$(date -Iseconds)
    local final_size=$(stat -f%z "$log_file" 2>/dev/null || stat -c%s "$log_file" 2>/dev/null || echo 0)
    update_metadata "$log_file" "$end_time" "$final_size"
    
    echo
    log_success "Session recorded to: $(basename "$log_file")"
    log_success "Session size: $(bytes_to_size "$final_size")"
    
    # Check if rotation is needed
    if check_file_size "$log_file"; then
        log_warning "Session file exceeds size limit, consider using --max-size option"
    fi
    
    exit $exit_code
}

# Handle signals gracefully
trap 'echo; log_info "Session interrupted by user"; exit 130' INT TERM

# Run main function
main "$@"